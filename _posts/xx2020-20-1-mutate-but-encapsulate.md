# Mutate, but encapsulate

There is a tension between the theoretical, mathematical beauty of computer science and the actual day to day engineering practice of software development. It has many names, sometimes it's called imperative vs declarative programming, procedural vs functional programming or maybe reference semantics vs value semantics, mutability vs immutability, stateless vs stateful. In graphical user interfaces, people talk about immediate mode vs retained mode, in web front-end it's React vs jQuery, in system administration it's Docker vs having someone setup a linux server for every new installation of the product. 

The reason this tension is created throughout our industry stems from the fact that our world is not mathematical. Our world is stateful, mutable and so is the Von Neumann architecture on which, as of now, all the software is running on. After all the compilation steps, even the most elegant Haskell program becomes a boring sequence of instructions that change bits in registers. In order to get actual work done, paradigms evolved over time that help climb the ladders of abstractions that help us build software collaboratively and much more quickly. Object-oriented programming makes programming easier through encapsulation, inheritance or polymorphism; functional programming with focus on immutability and referential transparency and declarative programming does away with the temporal aspect of programming by only describing what needs to be done.







